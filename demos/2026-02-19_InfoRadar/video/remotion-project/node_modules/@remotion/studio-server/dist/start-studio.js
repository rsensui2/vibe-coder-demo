"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startStudio = void 0;
const renderer_1 = require("@remotion/renderer");
const node_crypto_1 = __importDefault(require("node:crypto"));
const node_fs_1 = require("node:fs");
const node_path_1 = __importDefault(require("node:path"));
const get_network_address_1 = require("./get-network-address");
const maybe_open_browser_1 = require("./maybe-open-browser");
const close_and_restart_1 = require("./preview-server/close-and-restart");
const get_absolute_public_dir_1 = require("./preview-server/get-absolute-public-dir");
const live_events_1 = require("./preview-server/live-events");
const public_folder_1 = require("./preview-server/public-folder");
const start_server_1 = require("./preview-server/start-server");
const server_ready_1 = require("./server-ready");
const watch_root_file_1 = require("./watch-root-file");
const startStudio = async ({ browserArgs, browserFlag, configValueShouldOpenBrowser, fullEntryPath, logLevel, getCurrentInputProps, getEnvVariables, desiredPort, maxTimelineTracks, remotionRoot, keyboardShortcutsEnabled, experimentalClientSideRenderingEnabled, relativePublicDir, webpackOverride, poll, getRenderDefaults, getRenderQueue, numberOfAudioTags, queueMethods, parsedCliOpen, previewEntry, gitSource, bufferStateDelayInMilliseconds, binariesDirectory, forceIPv4, audioLatencyHint, enableCrossSiteIsolation, askAIEnabled, forceNew, }) => {
    try {
        if (typeof Bun === 'undefined') {
            process.title = 'node (npx remotion studio)';
        }
        else if (typeof Deno === 'undefined') {
            process.title = 'deno (npx remotiond studio)';
        }
        else {
            process.title = `bun (bunx remotionb studio)`;
        }
    }
    catch (_a) { }
    (0, watch_root_file_1.watchRootFile)(remotionRoot, previewEntry);
    const publicDir = (0, get_absolute_public_dir_1.getAbsolutePublicDir)({
        relativePublicDir,
        remotionRoot,
    });
    const hash = node_crypto_1.default.randomBytes(6).toString('hex');
    const outputHashPrefix = '/outputs-';
    const outputHash = `${outputHashPrefix}${hash}`;
    const staticHashPrefix = '/static-';
    const staticHash = `${staticHashPrefix}${hash}`;
    (0, public_folder_1.initPublicFolderWatch)({
        publicDir,
        remotionRoot,
        onUpdate: () => {
            (0, live_events_1.waitForLiveEventsListener)().then((listener) => {
                const files = (0, public_folder_1.getFiles)();
                listener.sendEventToClient({
                    type: 'new-public-folder',
                    files,
                    folderExists: files.length > 0
                        ? publicDir
                        : (0, node_fs_1.existsSync)(publicDir)
                            ? publicDir
                            : null,
                });
            });
        },
        staticHash,
    });
    const result = await (0, start_server_1.startServer)({
        entry: node_path_1.default.resolve(previewEntry),
        userDefinedComponent: fullEntryPath,
        getCurrentInputProps,
        getEnvVariables,
        port: desiredPort,
        maxTimelineTracks,
        remotionRoot,
        keyboardShortcutsEnabled,
        experimentalClientSideRenderingEnabled,
        publicDir,
        webpackOverride,
        poll,
        staticHash,
        staticHashPrefix,
        outputHash,
        outputHashPrefix,
        logLevel,
        getRenderDefaults,
        getRenderQueue,
        numberOfAudioTags,
        queueMethods,
        gitSource,
        bufferStateDelayInMilliseconds,
        binariesDirectory,
        forceIPv4,
        audioLatencyHint,
        enableCrossSiteIsolation,
        askAIEnabled,
        forceNew,
    });
    if (result.type === 'already-running') {
        renderer_1.RenderInternals.Log.info({ indent: false, logLevel }, `Already running on port ${result.port}.`);
        const res = await (0, maybe_open_browser_1.maybeOpenBrowser)({
            browserArgs,
            browserFlag,
            configValueShouldOpenBrowser,
            parsedCliOpen,
            url: `http://localhost:${result.port}`,
            logLevel,
        });
        if (res.didOpenBrowser) {
            renderer_1.RenderInternals.Log.info({ indent: false, logLevel }, 'Opened browser. Pass --force-new to force a new instance.');
        }
        return { type: 'already-running' };
    }
    const { port, liveEventsServer, close } = result;
    const cleanupLiveEventsListener = (0, live_events_1.setLiveEventsListener)(liveEventsServer);
    const networkAddress = (0, get_network_address_1.getNetworkAddress)();
    if (networkAddress) {
        (0, server_ready_1.setServerReadyComment)(`Local: ${renderer_1.RenderInternals.chalk.underline(`http://localhost:${port}`)}, Network: ${renderer_1.RenderInternals.chalk.underline(`http://${networkAddress}:${port}`)}`);
    }
    else {
        (0, server_ready_1.setServerReadyComment)(`http://localhost:${port}`);
    }
    (0, server_ready_1.printServerReadyComment)('Server ready', logLevel);
    renderer_1.RenderInternals.Log.info({ indent: false, logLevel }, 'Building...');
    await (0, maybe_open_browser_1.maybeOpenBrowser)({
        browserArgs,
        browserFlag,
        configValueShouldOpenBrowser,
        parsedCliOpen,
        url: `http://localhost:${port}`,
        logLevel,
    });
    await (0, close_and_restart_1.noOpUntilRestart)();
    renderer_1.RenderInternals.Log.info({ indent: false, logLevel }, 'Closing server to restart...');
    await liveEventsServer.closeConnections();
    cleanupLiveEventsListener();
    await close();
    renderer_1.RenderInternals.Log.info({ indent: false, logLevel }, renderer_1.RenderInternals.chalk.blue('Restarting server...'));
    return { type: 'restarted' };
};
exports.startStudio = startStudio;
